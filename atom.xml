<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wcctml</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://keepstan.ga/"/>
  <updated>2018-10-18T09:49:53.935Z</updated>
  <id>https://keepstan.ga/</id>
  
  <author>
    <name>Wcctml</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018年10月18日读报时间</title>
    <link href="https://keepstan.ga/posts/4e229866/"/>
    <id>https://keepstan.ga/posts/4e229866/</id>
    <published>2018-10-18T09:29:00.000Z</published>
    <updated>2018-10-18T09:49:53.935Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2018年10月18日</strong><br>星期四 读报时间<br>1、国家发改委等28部门联合发文，将对严重危害正常医疗秩序的失信行为责任人实施联合惩戒;<br>2、农业农村部副部长于康震带队赴北京市和天津市现场督导非洲猪瘟防控并召开座谈会：发挥联防联控机制，严防疫情扩散;<br>3、中国人民银行日前发布了公告，在银行间债券市场正式推出三方回购交易;<br>4、古驰因顾虑假货不愿与中国电商合作;<br>5、台湾当局官员赖清德主张“美台建交”，国台办昨日回应，这是一个做梦的人，说的是梦话;<br>6、西安面向全国公开招聘254名博士，拿出优厚的待遇政策留下人才;<br>7、云南昆明微信群主罗某默许他人在群中发布淫秽视频515个。因犯传播淫秽物品罪，罗某被法院判处有期徒刑6个月;<br>8、河南夏邑被指借棚改强征千亩耕地，当地回应：错发土地权证，将重新发证;<br>9、新财富不雅饭局处理结果出炉：分析师马军与同事廖蕾在饭局期间发生搂抱行为，方正证券对当事人马军予以降级降薪处罚;<br>10、我爱我家发布三季报：1至9月营收84亿元，同比增长797.10%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;2018年10月18日&lt;/strong&gt;&lt;br&gt;星期四 读报时间&lt;br&gt;1、国家发改委等28部门联合发文，将对严重危害正常医疗秩序的失信行为责任人实施联合惩戒;&lt;br&gt;2、农业农村部副部长于康震带队赴北京市和天津市现场督导非洲猪瘟防控并召开座谈会：发挥联防联
      
    
    </summary>
    
      <category term="每日早报" scheme="https://keepstan.ga/categories/%E6%AF%8F%E6%97%A5%E6%97%A9%E6%8A%A5/"/>
    
    
      <category term="每日早报" scheme="https://keepstan.ga/tags/%E6%AF%8F%E6%97%A5%E6%97%A9%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Windows进程间共享内核对象几种方式</title>
    <link href="https://keepstan.ga/posts/72cc9af1/"/>
    <id>https://keepstan.ga/posts/72cc9af1/</id>
    <published>2018-09-24T14:38:00.000Z</published>
    <updated>2018-10-18T09:43:39.805Z</updated>
    
    <content type="html"><![CDATA[<p>内核对象的句柄是进程相关的，这样更可靠，更安全；Windows提供下列N种机制来允许进程共享内核对象。</p><h2 id="使用对象句柄继承"><a href="#使用对象句柄继承" class="headerlink" title="使用对象句柄继承"></a>使用对象句柄继承</h2><p><strong>只有进程间存在父子关系才能使用对象句柄继承</strong>；系统会遍历父进程的句柄表将所有有效的句柄完整的复制到子进程的句柄表中（这个动作只会在创建子进程的进行一次，后续父进程再创建句柄对象，子进程不会再继承），并且增加句柄的使用计数（类似于智能指针，Close等操作只是将使用计数减一）。</p><p>CreateProcess创建进程，指定参数bInheritHandles为TRUE指定为父子进程，进行对象句柄继承，句柄跟进程有关，只有继承后子进程才能使用父进程句柄；</p><h3 id="使用进程间通信技术传递"><a href="#使用进程间通信技术传递" class="headerlink" title="使用进程间通信技术传递"></a>使用进程间通信技术传递</h3><ol><li>例如：通过命令行参数将句柄值传递给子进程）</li><li>通过设置父进程环境变量，子进程获取GetEnvironmentVariable；</li><li>如果子进程是有窗口的程序 通过函数WaitForInputIdle等待窗口程序初始化完成后 向窗口发消息；</li></ol><h3 id="改变句柄状态（控制哪些子进程可以继承内核对象句柄）"><a href="#改变句柄状态（控制哪些子进程可以继承内核对象句柄）" class="headerlink" title="改变句柄状态（控制哪些子进程可以继承内核对象句柄）"></a>改变句柄状态（控制哪些子进程可以继承内核对象句柄）</h3><p>父进程跟孙进程通信，不让子进程关闭句柄。通过SetHandleInfomation改变具柄状态，但是子进程也可以改这个状态从而关闭句柄（这就很尴尬了）。</p><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724935%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">SetHandleInformation具体使用请看MSDN</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI SetHandleInformation（</span><br><span class="line">  _In_ HANDLE hObject，//要设置其信息的对象的句柄。</span><br><span class="line">  _In_ DWORD dwMask，</span><br><span class="line">  _In_ DWORD dwFlags</span><br><span class="line">）;</span><br><span class="line"></span><br><span class="line">//每个句柄都关联了两个标志</span><br><span class="line">#define HANDLE_FLAG_INHERIT  0x00000001</span><br><span class="line">#define HANDLE_FLAG_PROTECT_FROM_CLOSE  0x00000002</span><br><span class="line"></span><br><span class="line">//打开内核对象句柄的继承标志</span><br><span class="line">SetHandleInformation(hObj, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);</span><br><span class="line">//关闭内核对象句柄的继承标志</span><br><span class="line">SetHandleInformation(hObj, HANDLE_FLAG_INHERIT, 0) ;</span><br><span class="line">//HANDLE_FLAG_PROTECT_FROM_CLOSE标志告诉系统不允许关闭句柄</span><br><span class="line">SetHandleInformation(hObj, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE);</span><br><span class="line">CloseHandle(h0bj); //会引发异常</span><br></pre></td></tr></table></figure><h2 id="命名对象"><a href="#命名对象" class="headerlink" title="命名对象"></a>命名对象</h2><p>通过对象的名称来共享内核对象，并不需要父子进程关系； windows大多数对象都可以进行命名，但是并没有提供保证为内核对象指定的名称是唯一的，所以命名可以以“公司名称+随机字符+名称”等方式来命名。以这样的私有命名方式，防止单实例程序被攻击（命名冲突，导致一直不能启动程序）。</p><p>调用（ Create ）系列函数可以通过调用GetLastError来判断是打开了一个已用的对象还是创建了一个新的对象。（Open）系列函数如果不存在否则返回NULL。</p><p>应用例子：<strong>可以利用命名对象来防止程序运行多个实例。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateMutex( </span><br><span class="line">  LPSECURITY_ATTRIBUTES lpMutexAttributes, </span><br><span class="line">  BOOL bInitialOwner, </span><br><span class="line">  LPCTSTR lpName //对象名称 传入NULL创建匿名对象</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">HANDLE hMutex = ::OpenMutex(MUTEX_ALL_ACCESS, FALSE, “Company_0DntbbRl5qP3_AppName”);</span><br><span class="line">if ( hMutex )</span><br><span class="line">&#123;</span><br><span class="line">    // 应用程序已存在实例</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    // 不存在，创建命名对象</span><br><span class="line">hMutex = ::CreateMutex(0, FALSE, “Company_0DntbbRl5qP3_AppName”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制对象句柄"><a href="#复制对象句柄" class="headerlink" title="复制对象句柄"></a>复制对象句柄</h2><p>获得一个进程的句柄表的一个记录项，然后在另外一个进程的句柄表中创建这个记录项的一个副本。同样的目标进程并不知道它能访问什么内核对象，必须使用进程间通信方式告诉它句柄值；这时已经启动，所以不能使用命令行参数或进程的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DuplicateHandle(</span><br><span class="line">  _In_  HANDLE   hSourceProcessHandle,     // 源进程内核对象</span><br><span class="line">  _In_  HANDLE   hSourceHandle,     // 源任何类型内核对象；不能与调用DuplicateHandle函数的进程相关，必须与hSourceProcessHandle句柄所标识的进程相关（除非hSourceProcessHandle就是调用DuplicateHandle函数的进程，即当前进程）</span><br><span class="line">  _In_  HANDLE   hTargetProcessHandle,     // 目标进程内核对象</span><br><span class="line">  _Out_ LPHANDLE lpTargetHandle,     // HANDLE变量的地址，用来接收复制得到的HANDLE值；不能调用CloseHandle（除非hTargetProcessHandle就是调用DuplicateHandle函数的进程，即当前进程）</span><br><span class="line">  _In_  DWORD    dwDesiredAccess,</span><br><span class="line">  _In_  BOOL     bInheritHandle,</span><br><span class="line">  _In_  DWORD    dwOptions</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>BTW：子进程与父进程通信不应该使用进程ID，应该使用内核对象或者窗口句柄等更持久的通信机制。因为系统分配进程ID是会回收重新使用的。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内核对象的句柄是进程相关的，这样更可靠，更安全；Windows提供下列N种机制来允许进程共享内核对象。&lt;/p&gt;&lt;h2 id=&quot;使用对象句柄继承&quot;&gt;&lt;a href=&quot;#使用对象句柄继承&quot; class=&quot;headerlink&quot; title=&quot;使用对象句柄继承&quot;&gt;&lt;/a&gt;使用对象
      
    
    </summary>
    
      <category term="Windows" scheme="https://keepstan.ga/categories/Windows/"/>
    
    
      <category term="Windows" scheme="https://keepstan.ga/tags/Windows/"/>
    
      <category term="内核对象" scheme="https://keepstan.ga/tags/%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++笔记 4-5</title>
    <link href="https://keepstan.ga/posts/20b36fe4/"/>
    <id>https://keepstan.ga/posts/20b36fe4/</id>
    <published>2018-05-22T15:27:00.000Z</published>
    <updated>2018-09-20T02:05:38.294Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://legacy.gitbook.com/book/wizardforcel/effective-cpp/details" target="_blank" rel="noopener">原书在线阅读</a></p><h3 id="条款04：-确保对象在使用前被初始化"><a href="#条款04：-确保对象在使用前被初始化" class="headerlink" title="条款04： 确保对象在使用前被初始化"></a>条款04： 确保对象在使用前被初始化</h3><p><strong>C风格数组不保证其内容被初始化，STL中vector保证初始化；</strong></p><p><strong>内置类型手工初始化,外置类型确保每一个构造函数都将对象的每一个成员初始化；</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;                                // manual initialization of an int</span><br><span class="line">const char * text = &quot;A C-style string&quot;;   // manual initialization of a</span><br><span class="line">                                          // pointer (see also Item 3)</span><br><span class="line">double d;                                 // &quot;initialization&quot; by reading from</span><br><span class="line">std::cin &gt;&gt; d;                            // an input stream</span><br></pre></td></tr></table></figure><p><strong>对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型初始化和赋值成本相同</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address,</span><br><span class="line">                 const std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">: theName(name),</span><br><span class="line">  theAddress(address),                  // these are now all initializations</span><br><span class="line">  thePhones(phones),</span><br><span class="line">  numTimesConsulted(0)</span><br><span class="line">&#123;&#125;                                      // the ctor body is now empty</span><br></pre></td></tr></table></figure><p></p><p>default构造成员变量<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry()</span><br><span class="line">:theName(),                         // call theName&apos;s default ctor;</span><br><span class="line"> theAddress(),                      // do the same for theAddress;</span><br><span class="line"> thePhones(),                       // and for thePhones;</span><br><span class="line"> numTimesConsulted(0)               // but explicitly initialize</span><br><span class="line">&#123;&#125;                                  // numTimesConsulted to zero</span><br></pre></td></tr></table></figure><p></p><p><strong>c++ 成员初始化顺序：base classes早于derived classes被初始化，class的成员变量比声明顺序初始化，成员初始化列表不影响初始化顺序，初始化array需要指定大小，代表大小的成员变量需要先有初值；</strong></p><p><strong>C++对于不同编译单元内的非局部静态对象的初始化次序没有明确定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//在tfs对象被创建之前不能使用。</span><br><span class="line">class FileSystem &#123;                    // from your library</span><br><span class="line">public:</span><br><span class="line">  std::size_t numDisks() const;       // one of many member functions</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern FileSystem tfs;                // object for clients to use;</span><br><span class="line">                                      // &quot;tfs&quot; = &quot;the file system&quot;</span><br><span class="line">                                      </span><br><span class="line">class Directory &#123;                     // created by library client</span><br><span class="line">public:</span><br><span class="line">   Directory( params );</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory( params )</span><br><span class="line">&#123;</span><br><span class="line">  std::size_t disks = tfs.numDisks();   // use the tfs object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将静态对象移到它自己的函数中声明为static。函数返回对象的引用。</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class FileSystem &#123; ... &#125;;           // as before</span><br><span class="line">FileSystem&amp; tfs()                   // this replaces the tfs object; it could be</span><br><span class="line">&#123;                                   // static in the FileSystem class</span><br><span class="line">  static FileSystem fs;             // define and initialize a local static object</span><br><span class="line">  return fs;                        // return a reference to it</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Directory &#123; ... &#125;;            // as before</span><br><span class="line"></span><br><span class="line">Directory::Directory( params )      // as before, except references to tfs are</span><br><span class="line">&#123;                                   // now to tfs()</span><br><span class="line">  std::size_t disks = tfs().numDisks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directory&amp; tempDir()                // this replaces the tempDir object; it</span><br><span class="line">&#123;                                   // could be static in the Directory class</span><br><span class="line">  static Directory td;              // define/initialize local static object</span><br><span class="line">  return td;                        // return reference to it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>在多线程中存在次序问题。解决这个麻烦的方法之一是在程序的单线程的启动部分手动调用所有初始化函数。避免 与初始化次序相关的混乱环境。</strong></p><p><strong>要点：</strong><br>避免在初始化之前使用对象，你只需要做三件事。首先，手动初始化内置类型的 非成员对象。第二，使用成员初始化列表初始化 对象的所有部分。最后，在设计中绕过搞乱定义在分离的转换单元中的非局部静态对象初始化顺序的不确定性。</p><p><strong>记住</strong></p><ol><li>手动初始化 built-in type（内建类型）的 objects（对象），因为 C++ 只在某些时候才会自己初始化它们。</li><li>构造函数使用成员初始化列表，成员初始化表的排列次序应该与class中声明次序相同；</li><li>为避免跨编译单元的初始化次序问题，以局部静态对象替换非局部静态对象；</li></ol><h3 id="条款05：-了解C-默默编写并调用了哪些函数"><a href="#条款05：-了解C-默默编写并调用了哪些函数" class="headerlink" title="条款05： 了解C++默默编写并调用了哪些函数"></a>条款05： 了解C++默默编写并调用了哪些函数</h3><p><strong>如果你没有声明，编译器默认生成的函数：copy构造函数、copy assignment操作符、析构函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Empty &#123;</span><br><span class="line">public:</span><br><span class="line">  Empty() &#123; ... &#125;                            // default constructor</span><br><span class="line">  Empty(const Empty&amp; rhs) &#123; ... &#125;            // copy constructor</span><br><span class="line">  ~Empty() &#123; ... &#125;                           // destructor — see below</span><br><span class="line">                                             // for whether it&apos;s virtual</span><br><span class="line">  Empty&amp; operator=(const Empty&amp; rhs) &#123; ... &#125; // copy assignment operator</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意，生成的析构函数是non-virtual的，除非基类声明了一个虚拟析构函数（这种情况下，函数的virtualness（虚拟性）来自基类）。</strong></p><p><strong>如果基类将copy assignment操作符声明为private，编译器拒绝为其派生类生成copy assignment运算符。</strong></p><p><strong>记住</strong></p><ol><li>编译器会暗自为class创建default构造函数、copy构造函数、copy assignment操作符、析构函数。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://legacy.gitbook.com/book/wizardforcel/effective-cpp/details&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原书在线阅读&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;条款04：-确
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://keepstan.ga/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++" scheme="https://keepstan.ga/tags/c/"/>
    
      <category term="读书笔记" scheme="https://keepstan.ga/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="effective c++" scheme="https://keepstan.ga/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++笔记 1-3  </title>
    <link href="https://keepstan.ga/posts/a180e4c3/"/>
    <id>https://keepstan.ga/posts/a180e4c3/</id>
    <published>2018-05-19T13:26:00.000Z</published>
    <updated>2018-09-25T09:44:56.755Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://legacy.gitbook.com/book/wizardforcel/effective-cpp/details" target="_blank" rel="noopener">原书在线阅读</a></p><h3 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h3><h3 id="条款02：尽量以const-enum-inline替换-define"><a href="#条款02：尽量以const-enum-inline替换-define" class="headerlink" title="条款02：尽量以const,enum,inline替换#define"></a>条款02：尽量以const,enum,inline替换#define</h3><ul><li><strong>宁可以编译器替换预处理器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//编译器错误信息中很可能用 1.653 取代了 ASPECT_RATIO</span><br><span class="line">//用 constant（常量）来替代 macro（宏）：</span><br><span class="line">#define ASPECT_RATIO 1.653</span><br><span class="line">const double AspectRatio = 1.653;</span><br><span class="line">//使用 constant（常量）比使用 #define 能产生更小的代码。</span><br><span class="line">//因为 preprocessor（预处理器）用1.653替换ASPECT_RATIO，导致object code中存在多个 1.653 的拷贝。</span><br></pre></td></tr></table></figure><ul><li><p><strong>两种例外的情况</strong></p><p>1、定义常量指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在头文件中定义一个基于char* 的字符串常量时，你必须写两次const：</span><br><span class="line">const char * const authorName = &quot;Scott Meyers&quot;;</span><br><span class="line">//string objects通常比 char*-based的更合适</span><br><span class="line">const std::string authorName(&quot;Scott Meyers&quot;);</span><br></pre></td></tr></table></figure></li></ul><pre><code>2、class专属常量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class GamePlayer </span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    static const int NumTurns = 5; // constant declaration</span><br><span class="line">    int scores[NumTurns]; // use of constant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//只要不取它们的地址，就无须提供定义式；</span><br><span class="line">//如果你需要取class专属常量的地址，你需要在实现文件提供如下这样一个独立的 定义：</span><br><span class="line">const int GamePlayer::NumTurns; // definition of NumTurns; see</span><br><span class="line">                                // below for why no value is given</span><br></pre></td></tr></table></figure>**#defines不仅不能用于定义class专属常量，而且不能提供任何形式的封装**</code></pre><ul><li><p><strong>enum hack</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//enum可以拒绝让别人通过指针或引用指向你的整数常量</span><br><span class="line">class GamePlayer </span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    enum &#123; NumTurns = 5 &#125;; // &quot;the enum hack&quot; - makes</span><br><span class="line">                           // NumTurns a symbolic name for 5</span><br><span class="line">    int scores[NumTurns]; // fine</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>宏夹带着宏实参调用函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// call f with the maximum of a and b</span><br><span class="line">#define CALL_WITH_MAX(a, b) f((a) &amp;gt; (b) ? (a) : (b))</span><br><span class="line">int a = 5, b = 0;</span><br><span class="line">CALL_WITH_MAX(++a, b); // a is incremented twice</span><br><span class="line">CALL_WITH_MAX(++a, b+10); // a is incremented once</span><br><span class="line"></span><br><span class="line">//用inline模板函数替换</span><br><span class="line">template&lt;typename T&gt;                               // because we don&apos;t</span><br><span class="line">inline void callWithMax(const T&amp; a, const T&amp; b)    // know what T is, we</span><br><span class="line">&#123;                                                  // pass by reference-to-</span><br><span class="line">                                                   // const - see Item 20</span><br><span class="line">    f(a &gt; b ? a : b);                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>记住</strong></p><p>1、对于单纯常量，用const对象或enums替换#defines。</p><p>2、对于类似函数的宏，用inline函数替换#defines。</p></li></ul><h3 id="条款03：尽可能的使用const"><a href="#条款03：尽可能的使用const" class="headerlink" title="条款03：尽可能的使用const"></a>条款03：尽可能的使用const</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char greeting[] = &quot;Hello&quot;;</span><br><span class="line">char *p = greeting; // non-const pointer, non-const data</span><br><span class="line">const char *p = greeting; // non-const pointer, const data</span><br><span class="line">char * const p = greeting; // const pointer, non-const data</span><br><span class="line">const char * const p = greeting; // const pointer, const data</span><br><span class="line"></span><br><span class="line">//如果const出现在星号左边，则指针指向的内容为常量；</span><br><span class="line">//如果const出现在星号右边，则指针自身为常量；</span><br><span class="line">//如果const出现在星号两边，则两者都为常量。</span><br></pre></td></tr></table></figure><p>当指针指向的内容为常量时，一些人将 const 放在类型之前，另一些人将它放在类型之后星号之前。两者在意义上并没有区别，所以，如下两个函数具有相同的参数类型：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void f1(const Widget *pw); //f1 takes a pointer to a constant Widget object</span><br><span class="line"></span><br><span class="line">void f2(Widget const *pw); //so does f2</span><br></pre></td></tr></table></figure><p></p><p>const iterator不能将这个iterator 指向另外的东西;但是它所指向的东西的值可以改动。如果你要一个iterator 指向的东西不可被改动，你需要const_iterator：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">// iter acts like a T* const</span><br><span class="line">const std::vector&lt;int&gt;::iterator iter = vec.begin();    </span><br><span class="line">*iter = 10; // OK, changes what iter points to</span><br><span class="line">++iter; // error! iter is const</span><br><span class="line">// cIter acts like a const T*</span><br><span class="line">std::vector&lt;int&gt;::const_iterator cIter = vec.begin(); </span><br><span class="line">*cIter = 10; // error! *cIter is const</span><br><span class="line">++cIter; // fine, changes cIter</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>令函数返回一个 const常量</strong></li></ul><p>除非你需要改变一个参数或作为本地对象的能力，否则确保将它声明为const。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);</span><br><span class="line">//避免下面这种行为</span><br><span class="line">(a * b) = c; // invoke operator= on the result of a*b!</span><br><span class="line">if (a * b = c) ... // 手残党的福音</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>const成员函数</strong></li></ul><p>mutable释放掉非静态数据成员bitwise constness（二进制位常量性）的约束：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  const char&amp; operator[](std::size_t position) const   // operator[] for</span><br><span class="line">  &#123; return text[position]; &#125;                           // const objects</span><br><span class="line"></span><br><span class="line">  char&amp; operator[](std::size_t position)               // operator[] for</span><br><span class="line">  &#123; return text[position]; &#125;  </span><br><span class="line"></span><br><span class="line">class CTextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">  std::size_t length() const;</span><br><span class="line">private:</span><br><span class="line">  char *pText;</span><br><span class="line">  mutable std::size_t textLength;         // these data members may</span><br><span class="line">  mutable bool lengthIsValid;             // always be modified, even in</span><br><span class="line">&#125;;                                        // const member functions</span><br><span class="line"></span><br><span class="line">std::size_t CTextBlock::length() const</span><br><span class="line">&#123;</span><br><span class="line">  if (!lengthIsValid) </span><br><span class="line">  &#123;</span><br><span class="line">    textLength = std::strlen(pText);      // now fine</span><br><span class="line">    lengthIsValid = true;                 // also fine</span><br><span class="line">  &#125;</span><br><span class="line">  return textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>避免const和non-const成员函数的重复</strong></li></ul><p>记住，一个const成员函数承诺绝不会改变它的对象的逻辑状态，non-const 成员函数却没有这样的承诺。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class TextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">  const char&amp; operator[](std::size_t position) const     // same as before</span><br><span class="line">  &#123;</span><br><span class="line">    return text[position];</span><br><span class="line">  &#125;</span><br><span class="line">  char&amp; operator[](std::size_t position)         // now just calls const op[]</span><br><span class="line">  &#123;</span><br><span class="line">    return</span><br><span class="line">      const_cast&lt;char&amp;&gt;(                         // cast away const on</span><br><span class="line">                                                 // op[]&apos;s return type;</span><br><span class="line">        static_cast&lt;const TextBlock&amp;&gt;(*this)     // add const to *this&apos;s type;</span><br><span class="line">          [position]                             // call const version of op[]</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ul><li><p><strong>记住</strong></p><p>1、将某些东西声明为const有助于编译器发现使用错误。const可被施加于任何作用域的对象、函数参数、函数返回类型、成员函数本体。</p><p>2、编译器强制实施 bitwise constness（二进制位常量性），但你编写程序时应使用 conceptual constness（概念上的常量性）。</p><p>3、当 const 和 non-const member成员函数有着本质上相同的实现时，应使用 non-const版本调用const版本避免代码重复。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://legacy.gitbook.com/book/wizardforcel/effective-cpp/details&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原书在线阅读&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;条款01：视C
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://keepstan.ga/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++" scheme="https://keepstan.ga/tags/c/"/>
    
      <category term="effectivec++" scheme="https://keepstan.ga/tags/effectivec/"/>
    
      <category term="读书笔记" scheme="https://keepstan.ga/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>老牌直播软件OBS-Studio编译环境生成&amp;&amp;在VS2017添加QtWebEngine</title>
    <link href="https://keepstan.ga/posts/9b548605/"/>
    <id>https://keepstan.ga/posts/9b548605/</id>
    <published>2017-12-25T12:24:00.000Z</published>
    <updated>2018-09-20T02:05:38.345Z</updated>
    
    <content type="html"><![CDATA[<p>直播元年早已过去。。。而我们才刚刚开始。</p><p>介绍老牌直播软件OBS-Studio编译的环境生成和Qt使用遇到的一些麻烦事。起到一个参考的作用。现在已经没有网上教程那么复杂。作为OBS官方文档的补充。</p><p>我的环境：Win10 64位 VS2017</p><p><strong>还在使用VS2010？，需要先去下载VS2013以上版本的IDE。</strong></p><p><strong><a href="https://blogs.msdn.microsoft.com/vcblog/2016/02/24/stuck-on-an-older-toolset-version-move-to-visual-studio-2015-without-upgrading-your-toolset/" target="_blank" rel="noopener">Stuck on an older toolset version? Move to Visual Studio 2017 without upgrading your toolset</a></strong></p><p><a href="https://github.com/jp9000/obs-studio/wiki/Install-Instructions#windows" target="_blank" rel="noopener">OBS官方构建教程</a></p><h2 id="首先是环境"><a href="#首先是环境" class="headerlink" title="首先是环境"></a>首先是环境</h2><p>Qt最新版不提供msvc2017_32位版本所以在网上找个别人编译好的。当然也可以直接使用msvc2015_32版本的，因为安装VS2017时也可以安装VS2015的平台工具集,然后你就需要参考这篇文章进行调整<a href="https://www.cnblogs.com/oloroso/p/6404475.html" target="_blank" rel="noopener">VS2017自带VS2015编译器等在命令行下无法使用问题</a>。</p><p>Qt5.9.1 msvc2017_32位版本(里面有32和64位的)：<a href="http://pan.baidu.com/s/1cgy7hG" target="_blank" rel="noopener">http://pan.baidu.com/s/1cgy7hG</a></p><p><strong>如果你直接有msvc2017_32就不需要安装Qt了，但是还是建议你装。</strong></p><p>Qt5.9.1版本<a href="http://download.qt.io/official_releases/qt/5.9/5.9.1/" target="_blank" rel="noopener">下载地址</a></p><p>cmake下载：我是64位系统直接选压缩包，解压可用。cmake-3.10.0-win64-x64.zip <a href="https://cmake.org/download/" target="_blank" rel="noopener">下载地址</a></p><p>下载安装DXSDK_Jun10.exe <a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=6812" target="_blank" rel="noopener">地址</a></p><p>OBS依赖下载</p><ul><li>VS2013: <a href="https://obsproject.com/downloads/dependencies2013.zip" target="_blank" rel="noopener">https://obsproject.com/downloads/dependencies2013.zip</a></li><li>VS2015: <a href="https://obsproject.com/downloads/dependencies2015.zip" target="_blank" rel="noopener">https://obsproject.com/downloads/dependencies2015.zip</a></li><li>VS2017: ABI compatible with VS2015<br>OBS官方给的依赖也是直接VS2015的。<strong>VS2017: ABI compatible with VS2015</strong></li></ul><p>保证所有代码拉取下来。包含子模块<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/jp9000/obs-studio.git</span><br></pre></td></tr></table></figure><p></p><p>打开CMake 设置依赖库DepsPath为dependencies到include目录；QTDIR设置到msvc2017_32目录。<br>先点‘Configure’ 生成vs项目文件要选择“Visual Studio 15 2017”。<br>点‘Generate’ 配置，生成项目文件。如果要生成64位程序所有对应的都要选择X64。</p><p><img src="http://orqvlsr1d.bkt.clouddn.com/OBS%E9%85%8D%E7%BD%AE.png" alt="image"></p><p><img src="http://orqvlsr1d.bkt.clouddn.com/OBS%E7%94%9F%E6%88%90.png" alt="image"></p><p>点击open打开项目，生成。我拉取时的代码有一个编译错误！更改命名后可以编译通过，等你拉到最新代码到时候官方应该已经改了。</p><p><img src="http://orqvlsr1d.bkt.clouddn.com/OBS%E7%BC%96%E8%AF%91.png" alt="image"></p><p>编译结束后，运行程序在rundir目录下。</p><h2 id="关于QtWebEngine"><a href="#关于QtWebEngine" class="headerlink" title="关于QtWebEngine"></a>关于QtWebEngine</h2><p>Qt使用Chromium替代Qt WebKit后是一个独立的模块，需要独立添加。如果使用Qt Creator进行开发，你只需要编辑.pro项目文件加上“QT += webkitwidgets”。如果你使用的是MSVC按以下介绍进行手动添加依赖。有时间的话可以写到MakeList就不用每个人都搞一遍。</p><p>基本步骤就是按第三篇文档添加，最后还需要按第二篇文档说的把Chromium依赖资源文件拷贝到运行程序目录。</p><ul><li><a href="http://doc.qt.io/qt-5/qtwebengine-index.html" target="_blank" rel="noopener">QtWebEngine介绍</a></li><li><a href="http://doc.qt.io/qt-5/qtwebengine-deploying.html" target="_blank" rel="noopener">部署QtWebEngine官方文档</a></li><li><a href="http://blog.csdn.net/qing666888/article/details/76796011" target="_blank" rel="noopener">网上一篇文章</a></li></ul><h2 id="Qt程序接下来可能会遇到的问题："><a href="#Qt程序接下来可能会遇到的问题：" class="headerlink" title="Qt程序接下来可能会遇到的问题："></a>Qt程序接下来可能会遇到的问题：</h2><ul><li><a href="https://www.zhihu.com/question/51105941" target="_blank" rel="noopener">减少Qt程序体积</a></li></ul><h2 id="如果你需要编译obs-browser-cef3内核浏览器插件"><a href="#如果你需要编译obs-browser-cef3内核浏览器插件" class="headerlink" title="如果你需要编译obs-browser(cef3内核浏览器插件):"></a>如果你需要编译obs-browser(cef3内核浏览器插件):</h2><ul><li><p>先需要编译CEF Standard Distribution cef_binary_3.3202.1694.gf061c23_windows32.tar.bz2<a href="http://opensource.spotify.com/cefbuilds/index.html" target="_blank" rel="noopener">下载</a></p></li><li><p>解压后打开cmake,选择对应的路径，先”Configure”选择vs2017，再”Generate”,”Open project” 编译生成。<br><img src="http://orqvlsr1d.bkt.clouddn.com/cef3%E7%94%9F%E6%88%90.png" alt="image"></p></li></ul><p>再回到OBS的生成<br>需要勾选 BUILD_BROWSER ，还需要增加配置下面两个变量,<br>是你编译生成后的项目目录<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CEFWRAPPER_LIBRARY = E:/code/cef_binary_3.3202.1694.gf061c23_windows32/build/libcef_dll_wrapper/Release/libcef_dll_wrapper.lib</span><br><span class="line">CEF_ROOT_DIR ＝ E:/code/cef_binary_3.3202.1694.gf061c23_windows32</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直播元年早已过去。。。而我们才刚刚开始。&lt;/p&gt;&lt;p&gt;介绍老牌直播软件OBS-Studio编译的环境生成和Qt使用遇到的一些麻烦事。起到一个参考的作用。现在已经没有网上教程那么复杂。作为OBS官方文档的补充。&lt;/p&gt;&lt;p&gt;我的环境：Win10 64位 VS2017&lt;/p&gt;&lt;
      
    
    </summary>
    
      <category term="obs" scheme="https://keepstan.ga/categories/obs/"/>
    
    
      <category term="OBS" scheme="https://keepstan.ga/tags/OBS/"/>
    
      <category term="直播" scheme="https://keepstan.ga/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="编译" scheme="https://keepstan.ga/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="obsstudio" scheme="https://keepstan.ga/tags/obsstudio/"/>
    
  </entry>
  
  <entry>
    <title>python生成自定义中文词云学习日记</title>
    <link href="https://keepstan.ga/posts/235ba016/"/>
    <id>https://keepstan.ga/posts/235ba016/</id>
    <published>2017-12-15T13:51:00.000Z</published>
    <updated>2018-09-20T02:05:38.320Z</updated>
    
    <content type="html"><![CDATA[<p>接上文 从CentOS安装完成到生成词云python学习日记</p><p>对源代码进行修改生成中文词云；可以随便找一篇中文文章，我这里下载了一部小说《多情剑客无情剑》进行词云绘制。还根据背景图片生成了自定义的词云；源码的说明看注释。</p><p>先安装jieba中文分词库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jieba</span><br></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import matplotlib</span><br><span class="line"># Force matplotlib to not use any Xwindows backend.</span><br><span class="line">#matplotlib.use(&apos;Agg&apos;)</span><br><span class="line">import jieba</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">backgroud_image = plt.imread(&apos;man.jpg&apos;) #设置背景图片</span><br><span class="line">textfile = open(&quot;TheSentimentalSwordsman.txt&quot;,&apos;r&apos;).read()</span><br><span class="line">#join的用法</span><br><span class="line">#str = &quot;-&quot;;</span><br><span class="line">#seq = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); # 字符串序列</span><br><span class="line">#print str.join( seq );</span><br><span class="line">#输出为a-b-c</span><br><span class="line">cut_text = &quot; &quot;.join(jieba.cut(textfile)) #使用了jieba中文分词</span><br><span class="line">wordcloud = WordCloud(font_path=&quot;./simhei.ttf&quot;,</span><br><span class="line">width=800, height=600, margin=5, max_words=2000,mask=backgroud_image).generate(cut_text)</span><br><span class="line"></span><br><span class="line"># mask=backgroud_Image,设置背景图片 全白（#FFFFFF）的部分将不会绘制，其余部分会用于绘制词云。</span><br><span class="line"># width,height,margin可以设置图片属性</span><br><span class="line"># generate 可以对全部文本进行自动分词,但是他对中文支持不好</span><br><span class="line"># 你可以通过font_path参数来设置字体集</span><br><span class="line"># background_color参数为设置背景颜色,默认颜色为黑色</span><br><span class="line"></span><br><span class="line">wordcloud.to_file(&quot;TheSentimentalSwordsman.png&quot;)</span><br></pre></td></tr></table></figure><p>普通生成的中文词云</p><p><img src="http://orqvlsr1d.bkt.clouddn.com/TheSentimentalSwordsman1.png" alt="image"></p><p>原图不需要绘制的地方为存白色。用ps弄的。</p><p><img src="http://orqvlsr1d.bkt.clouddn.com/%E5%B0%8F%E6%9D%8E%E9%A3%9E%E5%88%80.jpg" alt="image"></p><p>自定义图片绘制词云效果</p><p><img src="http://orqvlsr1d.bkt.clouddn.com/TheSentimentalSwordsman.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接上文 从CentOS安装完成到生成词云python学习日记&lt;/p&gt;&lt;p&gt;对源代码进行修改生成中文词云；可以随便找一篇中文文章，我这里下载了一部小说《多情剑客无情剑》进行词云绘制。还根据背景图片生成了自定义的词云；源码的说明看注释。&lt;/p&gt;&lt;p&gt;先安装jieba中文分词库&lt;
      
    
    </summary>
    
      <category term="python" scheme="https://keepstan.ga/categories/python/"/>
    
    
      <category term="python" scheme="https://keepstan.ga/tags/python/"/>
    
      <category term="中文词云" scheme="https://keepstan.ga/tags/%E4%B8%AD%E6%96%87%E8%AF%8D%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>从CentOS安装完成到生成词云python学习日记</title>
    <link href="https://keepstan.ga/posts/2eba6da3/"/>
    <id>https://keepstan.ga/posts/2eba6da3/</id>
    <published>2017-11-30T14:51:00.000Z</published>
    <updated>2018-09-20T02:05:38.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人生苦短，我用python。学习python怎么能不搞一下词云呢是不是(ง •̀_•́)ง<br>于是便有了这篇边实践边记录的笔记。</p><p>环境：VMware 12pro + CentOS7 + Python 2.7.5</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>之前一直用的是win10子系统，现在试试CentOS，CentOS官网下载最新系统dvd版 安装到VMware 12pro。网上很多教程。例如这个<a href="https://jingyan.baidu.com/article/a3f121e4b18b74fc9052bb14.html" target="_blank" rel="noopener">链接</a>。等待安装完成后开始。</p><h2 id="第一个命令"><a href="#第一个命令" class="headerlink" title="第一个命令"></a>第一个命令</h2><p>用Ubuntu的时候没有的命令会提示你安装，感觉很简单的事。但是到CentOS上却变得很头痛。</p><p>打开终端在执行以下命令安装python-pip时提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python-pip</span><br><span class="line"></span><br><span class="line">没有可用软件包 python-pip。</span><br></pre></td></tr></table></figure><p>google了一下说是这个包在EPEL源里，要添加EPEL源才可以。<br>执行下面两个命令就安装好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release.noarch </span><br><span class="line"></span><br><span class="line">yum install python-pip</span><br></pre></td></tr></table></figure><h2 id="python库安装"><a href="#python库安装" class="headerlink" title="python库安装"></a>python库安装</h2><p>接下来安装一个词云<strong>wordcloud</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple wordcloud</span><br><span class="line"></span><br><span class="line">截取部分提示错误信息 </span><br><span class="line">unable to execute gcc: No such file or directory</span><br><span class="line">error: command &apos;gcc&apos; failed with exit status 1</span><br><span class="line"></span><br><span class="line">连gcc都没有(ง •̀_•́)ง。先安装gcc</span><br><span class="line">yum install gcc</span><br></pre></td></tr></table></figure><p>gcc装完后继续安装wordcloud!又报了下面的错误<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_posixsubprocess.c:3:20: 致命错误：Python.h：没有那个文件或目录</span><br><span class="line"></span><br><span class="line">于是需要先安装python-devel</span><br><span class="line"></span><br><span class="line">sudo yum install python-devel　　#注意这里不是python-dev</span><br></pre></td></tr></table></figure><p></p><p>CentOS 下叫做 <strong>python-devel</strong>，Ubuntu 下还是叫做 <strong>python-dev</strong>。</p><p><strong>wordcloud安装完毕</strong>！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>生成词云一份代码，并且随便找一份英文（我在ChinaDaily找的文章 <a href="http://www.chinadaily.com.cn/china/2017-11/28/content_35086176.htm" target="_blank" rel="noopener">Recruiters starting to employ social media</a> 放到 txt/word.txt中<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import matplotlib</span><br><span class="line"># Force matplotlib to not use any Xwindows backend.</span><br><span class="line">#matplotlib.use(&apos;Agg&apos;)</span><br><span class="line"></span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line"></span><br><span class="line">textfile = open(u&apos;txt/word.txt&apos;,&apos;r&apos;).read()</span><br><span class="line">wordcloud = WordCloud(background_color=&quot;white&quot;,width=800, height=600, margin=5).generate(textfile)</span><br><span class="line"></span><br><span class="line"># width,height,margin可以设置图片属性</span><br><span class="line"># generate 可以对全部文本进行自动分词,但是它对中文支持不好</span><br><span class="line">#background_color参数为设置背景颜色,默认颜色为黑色</span><br><span class="line"></span><br><span class="line">wordcloud.to_file(&apos;word.png&apos;)</span><br></pre></td></tr></table></figure><p></p><p>执行命令运行 python clouddemo.py 报错提示<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character &apos;\xe5&apos; in file clouddemo.py on line 6, </span><br><span class="line">but no encoding declared; see http://www.python.org/peps/pep-0263.html for details</span><br></pre></td></tr></table></figure><p></p><h3 id="原因如下"><a href="#原因如下" class="headerlink" title="原因如下"></a>原因如下</h3><blockquote><p>Python默认是以ASCII作为编码方式的，如果在Python源码中包含了中文（或者其他非英语系的语言），此时即使你把自己编写的Python源文件以UTF-8格式保存，但实际上，这依然是不行的。<br>解决办法很简单，只要在文件开头加入下面代码；指定文件的编码格式为utf-8。上面的代码我已经加好了(。・`ω´・)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br></pre></td></tr></table></figure><p></p></blockquote><p>编码问题解决了。接下来重新运行。<br>还是报错！！！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: No module named Tkinter</span><br></pre></td></tr></table></figure><p></p><p>首先yum list installed | grep ^tk<br>查看是否存在相应模块，如果不存在则通过yum install tkinter 和yum install -y tk-devel下载相应模块。</p><p>重新执行命令提示下一个错误<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_tkinter.TclError: no display name and no $DISPLAY environment variable</span><br></pre></td></tr></table></figure><p></p><p>虽然一波N折，但是最后还是成功了！！！看看源代码目录下的词云图！<br>效果图如下：<br><img src="http://orqvlsr1d.bkt.clouddn.com/word.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;人生苦短，我用python。学习python怎么能不搞一下词云呢是不是(ง •̀_•́)ง&lt;br&gt;于是便有了这篇边实践边记录的笔记。&lt;/p&gt;
      
    
    </summary>
    
      <category term="python" scheme="https://keepstan.ga/categories/python/"/>
    
    
      <category term="python" scheme="https://keepstan.ga/tags/python/"/>
    
      <category term="词云" scheme="https://keepstan.ga/tags/%E8%AF%8D%E4%BA%91/"/>
    
      <category term="wordcloud" scheme="https://keepstan.ga/tags/wordcloud/"/>
    
  </entry>
  
  <entry>
    <title>网站不带WWW访问时矢量字体加载不出来</title>
    <link href="https://keepstan.ga/posts/75663ba8/"/>
    <id>https://keepstan.ga/posts/75663ba8/</id>
    <published>2017-11-07T14:57:00.000Z</published>
    <updated>2018-09-25T08:59:10.536Z</updated>
    
    <content type="html"><![CDATA[<p>由于博客使用了一些矢量字体代替图标，但是习惯直接输入域名不带www访问博客时经常加载不出来，提示错误如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access to Font at &apos;usr/themes/fonts/fontawesome-webfont.ttf?v=4.6.3&apos;</span><br><span class="line">from origin &apos;&apos; has been blocked by CORS policy: No &apos;Access-Control-Allow-Origin&apos;</span><br><span class="line">header is present on the requested resource. Origin &apos;&apos; is therefore not allowed</span><br><span class="line">access.</span><br></pre></td></tr></table></figure><p>本人也不是搞web开发的，一开始不清楚，还以为是跨域的问题，还去给作者提了Issues。O(∩_∩)O</p><p>慢慢后来发现带www访问的时候能百分百加载出来，不带的www就加载不出来，于是去搜索才发现原来是这样子。baidu.com 和 <a href="http://www.baidu.com。实际上这两个是完全不同的域名，只是为了访问方便而许多大网站都对不带WWW的域名做了跳转。所实现的技术就叫做301重定向，这样设置可以让用户的体验更好，何乐而不为呢？" target="_blank" rel="noopener">www.baidu.com。实际上这两个是完全不同的域名，只是为了访问方便而许多大网站都对不带WWW的域名做了跳转。所实现的技术就叫做301重定向，这样设置可以让用户的体验更好，何乐而不为呢？</a></p><p>只需要在网站/public_html/目录下创建.htaccess这个文件。然后添加如下规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Files ~ &quot;^.(htaccess|htpasswd)$&quot;&gt;</span><br><span class="line">deny from all</span><br><span class="line">&lt;/Files&gt;</span><br><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond %&#123;HTTP_HOST&#125; ^(domain\.com)(:80)? [NC]</span><br><span class="line">RewriteRule ^(.*) http://www.domain.com/$1 [R=301,L]</span><br><span class="line">order deny,allow</span><br></pre></td></tr></table></figure><p><strong>domain.com就是你的域名</strong> 替换就行了</p><p><a href="https://baike.baidu.com/item/%E9%87%8D%E5%AE%9A%E5%90%91/9064196?fr=aladdin" target="_blank" rel="noopener">更详细请参考百科</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于博客使用了一些矢量字体代替图标，但是习惯直接输入域名不带www访问博客时经常加载不出来，提示错误如下。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="运维" scheme="https://keepstan.ga/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="网站重定向" scheme="https://keepstan.ga/tags/%E7%BD%91%E7%AB%99%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>C++  构造函数 explicit关键字不起作用的一次小坑记录</title>
    <link href="https://keepstan.ga/posts/413d867/"/>
    <id>https://keepstan.ga/posts/413d867/</id>
    <published>2017-11-04T16:11:00.000Z</published>
    <updated>2018-09-25T09:50:24.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++中的explicit关键字只能用于修饰只有一个参数的类构造函数,它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的, 类构造函数默认情况下即声明为implicit(隐式)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class CGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">explicit CGay(bool bShow = false, const string strName = &quot;&quot;);</span><br><span class="line">~CGay();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">bool m_bShow;</span><br><span class="line">string m_strName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CGay::CGay(bool bShow, const string strName)</span><br><span class="line">&#123;</span><br><span class="line">m_bShow = bShow;</span><br><span class="line">m_strName = strName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGay::~CGay()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const string GAY = &quot;GAY&quot;;</span><br><span class="line">CGay aGay(GAY); //调用失败</span><br><span class="line">CGay aGay(&quot;Gay1&quot;); //调用成功被隐式转换为了CGay(true,&quot;&quot;);</span><br><span class="line">CGay aGay(1); //调用成功被隐式转换为了CGay(true,&quot;&quot;);</span><br></pre></td></tr></table></figure><p>如果之前的构造函数是<strong>CGay(const string strName = “”)</strong>，并且已经有几个地方被使用过了。</p><p>调用是这样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGay aGay(&quot;Gay1&quot;);</span><br><span class="line">CGay aGay(&quot;Gay2&quot;);</span><br></pre></td></tr></table></figure><p></p><p>然后又增加了一个新的默认参数改成<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGay(bool bShow = false, const string strName = &quot;&quot;);</span><br></pre></td></tr></table></figure><p></p><p>之前写的Gay1、Gay2都不会有任何报错提示。合法的。这样就很坑了。</p><ul><li>增加一个参数的时候，从后面增加；</li><li>不要在构造函数里写这种幺蛾子，增加一个void SetShow(bool bShow)的接口；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;C++中的explicit关键字只能用于修饰只有一个参数的类构造函数,它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的, 类构造函数默认情况下即声明为implicit(隐式)。&lt;/p&gt;&lt;/b
      
    
    </summary>
    
      <category term="c++" scheme="https://keepstan.ga/categories/c/"/>
    
    
      <category term="explicit" scheme="https://keepstan.ga/tags/explicit/"/>
    
  </entry>
  
  <entry>
    <title>vld配置 应用程序正常初始化 0x0150002失败 bug解决记录</title>
    <link href="https://keepstan.ga/posts/23a00bb/"/>
    <id>https://keepstan.ga/posts/23a00bb/</id>
    <published>2017-10-29T14:59:00.000Z</published>
    <updated>2018-09-20T02:05:38.325Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中使用了visual leak detector，编译时没有任何错误，相应的库文件也有了，但是运行时就提示，应用程序无法正常启动 0x0150002 请单击确定关闭应用程序。</p><p><img src="http://orqvlsr1d.bkt.clouddn.com/vld%E5%87%BA%E9%94%99.png" alt="image"></p><p>win10搜索事件查看器，找到对应的出错日志，如下图：<br><img src="http://orqvlsr1d.bkt.clouddn.com/%E4%BA%8B%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%9B%BE%E7%89%87.png" alt="image"><br><strong>错误提示为：</strong> vld_x86.dll”的激活上下文生成失败。 找不到从属程序集 Microsoft.DTfW.DHL,processorArchitecture=”x86”,type=”win32”,version=”6.11.1.404”。 请使用 sxstrace.exe 进行详细诊断。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>把VLD中的文件复制到执行文件目录下就正常了</p><ul><li>Microsoft.DTfW.DHL.manifest</li><li>vld_x86.dll</li></ul><p>有时候运行出错还需要复制这个</p><ul><li>dbghelp.dll</li></ul><blockquote><p><a href="http://blog.csdn.net/evilswords/article/details/5698851" target="_blank" rel="noopener">网上的详细分析文章</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中使用了visual leak detector，编译时没有任何错误，相应的库文件也有了，但是运行时就提示，应用程序无法正常启动 0x0150002 请单击确定关闭应用程序。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://orqvlsr1d.bkt.clouddn.c
      
    
    </summary>
    
    
      <category term="vld" scheme="https://keepstan.ga/tags/vld/"/>
    
      <category term="0x0150002" scheme="https://keepstan.ga/tags/0x0150002/"/>
    
  </entry>
  
  <entry>
    <title>Facebook开源Zstandard新型压缩算法 简单使用</title>
    <link href="https://keepstan.ga/posts/ee0e8983/"/>
    <id>https://keepstan.ga/posts/ee0e8983/</id>
    <published>2017-06-18T11:34:00.000Z</published>
    <updated>2018-09-20T02:05:38.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Zstandard（缩写为Zstd）是由Facebook的Yann Collet开发的一个无损数据压缩算法。Zstandard在设计上与DEFLATE（.zip、gzip）算法有着差不多的压缩比，但有更高的压缩和解压缩速度。<br>Zstandard使用字典算法（LZ77）结合熵编码法的有限状态熵（tANS）。—–Wikipedia</p></blockquote><p><a href="https://github.com/facebook/zstd" target="_blank" rel="noopener">GitHub上的zstd页面</a></p><table><thead><tr><th>Compressor name</th><th>Ratio</th><th>Compression</th><th>Decompress.</th></tr></thead><tbody><tr><td><strong>zstd 1.1.3 -1</strong></td><td>2.877</td><td>430 MB/s</td><td>1110 MB/s</td></tr><tr><td>zlib 1.2.8 -1</td><td>2.743</td><td>110 MB/s</td><td>400 MB/s</td></tr><tr><td>brotli 0.5.2 -0</td><td>2.708</td><td>400 MB/s</td><td>430 MB/s</td></tr><tr><td>quicklz 1.5.0 -1</td><td>2.238</td><td>550 MB/s</td><td>710 MB/s</td></tr><tr><td>lzo1x 2.09 -1</td><td>2.108</td><td>650 MB/s</td><td>830 MB/s</td></tr><tr><td>lz4 1.7.5</td><td>2.101</td><td>720 MB/s</td><td>3600 MB/s</td></tr><tr><td>snappy 1.1.3</td><td>2.091</td><td>500 MB/s</td><td>1650 MB/s</td></tr><tr><td>lzf 3.6 -1</td><td>2.077</td><td>400 MB/s</td><td>860 MB/s</td></tr></tbody></table><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="在Windows下Build"><a href="#在Windows下Build" class="headerlink" title="在Windows下Build"></a>在Windows下Build</h2><p>很简单，进入\build\VS_scripts目录下根据不同环境运行相应的脚本即可！</p><ul><li>在项目中包含头文件#include “zstd/zstd.h”</li><li>#pragma comment(lib,”libzstd.lib”);</li><li>在项目exe目录下面加入libzstd.dll文件</li><li>在项目lib文件夹(或者其他什么文件夹)加入libzstd.lib</li></ul><p><img src="http://orqvlsr1d.bkt.clouddn.com/cnblogsJ%7DLAD6IG%28_L8Z%7D%5DE3X7%60%600X.jpg?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|watermark/2/text/5Y2a5a6i5Zut5L2c6ICFd2NjdG1s/font/5b6u6L2v6ZuF6buR/fontsize/1000/fill/IzBDM0NGRA==/dissolve/66/gravity/Center/dx/10/dy/10|imageslim" alt="image"></p><h2 id="四个Simple-API"><a href="#四个Simple-API" class="headerlink" title="四个Simple API"></a>四个Simple API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*! ZSTD_compress() :</span><br><span class="line"> *  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.</span><br><span class="line"> *  Hint : compression runs faster if `dstCapacity` &gt;=  `ZSTD_compressBound(srcSize)`.</span><br><span class="line"> *  @return : compressed size written into `dst` (&lt;= `dstCapacity),</span><br><span class="line"> *            or an error code if it fails (which can be tested using ZSTD_isError()). */</span><br><span class="line">ZSTDLIB_API size_t ZSTD_compress( void* dst, size_t dstCapacity,</span><br><span class="line">                            const void* src, size_t srcSize,</span><br><span class="line">                                  int compressionLevel);</span><br><span class="line"></span><br><span class="line">/*! ZSTD_decompress() :</span><br><span class="line"> *  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.</span><br><span class="line"> *  `dstCapacity` is an upper bound of originalSize.</span><br><span class="line"> *  If user cannot imply a maximum upper bound, it&apos;s better to use streaming mode to decompress data.</span><br><span class="line"> *  @return : the number of bytes decompressed into `dst` (&lt;= `dstCapacity`),</span><br><span class="line"> *            or an errorCode if it fails (which can be tested using ZSTD_isError()). */</span><br><span class="line">ZSTDLIB_API size_t ZSTD_decompress( void* dst, size_t dstCapacity,</span><br><span class="line">                              const void* src, size_t compressedSize);</span><br><span class="line">                              </span><br><span class="line">ZSTDLIB_API unsigned long long ZSTD_getDecompressedSize(const void* src, size_t srcSize);</span><br><span class="line"></span><br><span class="line"> /*!&lt; maximum compressed size in worst case scenario */</span><br><span class="line">ZSTDLIB_API size_t ZSTD_compressBound(size_t srcSize);</span><br></pre></td></tr></table></figure><p>压缩流程：</p><ul><li>使用ZSTD_compressBound获取最大压缩缓冲区大小，然后申请缓冲区；</li><li>使用ZSTD_compress进行压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//可以设定压缩等级 1 up to ZSTD_maxCLevel()</span><br><span class="line">size_t dstSize = ZSTD_compress(pDest, szBufSize, pSource, szSrcSize, iCompressLevel);</span><br><span class="line">if (ZSTD_isError(dstSize))</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">return dstSize;</span><br></pre></td></tr></table></figure><p>解压流程：</p><ul><li>可以使用ZSTD_getDecompressedSize来获取压缩后最大缓冲区大小；来申请解压缓冲区；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size_t dstSize = ZSTD_decompress(pDest, szBufSize, pSource, szSrcSize);</span><br><span class="line">if (ZSTD_isError(dstSize))</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">return dstSize;</span><br></pre></td></tr></table></figure></li></ul><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;Zstandard（缩写为Zstd）是由Facebook的Yann Collet开发的一个无损数据压缩算法。Zsta
      
    
    </summary>
    
      <category term="压缩算法" scheme="https://keepstan.ga/categories/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c++" scheme="https://keepstan.ga/tags/c/"/>
    
      <category term="Zstandard" scheme="https://keepstan.ga/tags/Zstandard/"/>
    
      <category term="zstd" scheme="https://keepstan.ga/tags/zstd/"/>
    
      <category term="压缩" scheme="https://keepstan.ga/tags/%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
</feed>
